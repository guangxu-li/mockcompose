# mockcompose

I found that it seems to be quite difficult in Go to do something which is relatively easy in other object oriented languages. For example, in Java, I can mix real method call with mocked sibling method calls like this:
```java
FooService fooService = PowerMockito.mock(FooService.class);
PowerMockito.doCallRealMethod().when(fooService).SomeFooMethod());
```
In the example, SomeFooMethod() will be called to run real implementation code, while any sibling method that SomeFooMethod() calls will be taken from the mocked version. This ability can give us a fine-grained granularity control in unit testing, which I think it is quite essential.

Without such granularity control, we have to rely heavily on end to end integration tests. The integration test approach involves a lot of effort to bring up either real or simulated runtime with third-party dependencies, it is also hard and tedious to perform fault injections.

## Solution
[mockery](https://github.com/vektra/mockery) is a very nice tool that allows developers to generate mocking interface implementation in Go, however, it is not enough to satisfy the requriements mentioned above. With the best that [mockery](https://github.com/vektra/mockery) can offer, mockcompose can generate the mocking class by blending copies of real method code and copies from [mockery](https://github.com/vektra/mockery) generated mocking method code.

## Installation
```
go install github.com/kelveny/mockcompose
```

## Usage

```
  mockcompose can be launched with following options

  -c string
        Name of the class for which to generate composite mocking implementation
  -m string
        Name of the mocking class that implements the same interface as -c specified class
  -mm string
        Name of the file that implements -m specified mocking class
  -mock value
        Name of the method function name to be mocked
  -n string
        Name of the class(struct) with composite mocking implementation
  -pkg string
        Name of the package for which to generate composite mocking implementation
  -real value
        Name of the method function name to be cloned from class implementation
```
If -pkg option is omitted, mockcompose will try to derive Go package name from current working directory, it assumes that Go package name follows directory name. Otherwise, please specify it explicitly.

You can use multiple -real and -mock options to specify a set of real class method functions to clone and another set of mocked class method functions. mockcompose currently does not generate mocking code for mocked functions, instead, it pulls code from existing mocked class (for example, generated from [mockery](https://github.com/vektra/mockery)).

mockcompose can also be used in 'go generate', usually together with [mockery](https://github.com/vektra/mockery), as following example shows:
```go
//go:generate mockery --inpackage --testonly --name Foo
//go:generate mockcompose -n testFoo -c foo -m MockFoo -mm mock_Foo_test.go -real Foo -mock Bar
```
In the example, mockcompose will generate a testFoo class with Foo() method function cloned from real foo class implementation, and Bar() method function cloned from MockFoo class mocking code.

foo.go
```go
package fooapp

type Foo interface {
	Foo() string
	Bar() bool
}

type foo struct {
	name string
}

var _ Foo = (*foo)(nil)

func (f *foo) Foo() string {
	if f.Bar() {
		return "Overriden with Bar"
	}

	return f.name
}

func (f *foo) Bar() bool {
	if f.name == "bar" {
		return true
	}

	return false
}
```

mockery generated mock_Foo_test.go
```go
// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package fooapp

import mock "github.com/stretchr/testify/mock"

// MockFoo is an autogenerated mock type for the Foo type
type MockFoo struct {
	mock.Mock
}

// Bar provides a mock function with given fields:
func (_m *MockFoo) Bar() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Foo provides a mock function with given fields:
func (_m *MockFoo) Foo() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}
```

mockcompose generated code
```go
/*
 * CODE GENERATED AUTOMATICALLY WITH github.com/kelveny/mockcompose
 * THIS FILE SHOULD NOT BE EDITED BY HAND
 *
 */
package fooapp

type testFoo struct {
	foo
	MockFoo
}

func (f *testFoo) Foo() string {
	if f.Bar() {
		return "Overriden with Bar"
	}
	return f.name
}

func (_m *testFoo) Bar() bool {
	ret := _m.Called()
	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

```

Equipped with these, you can write unit tests to test at fine-grained granularity. This can enable to test individual or a group of class method functions, with dependency closure be mocked.

```go
func TestFoo(t *testing.T) {
    assert := require.New(t)

    fooObj := &testFoo{}

    // Mock sibling method Bar()
    fooObj.On("Bar").Return(false)

    s := fooObj.Foo()
    assert.True(s == "")
}
```
